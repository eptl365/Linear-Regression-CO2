import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("/Users/eshanpatel/Downloads/co2.csv")

#cost function
def compute_cost(theta0, theta1, theta2, X1, X2, y):
    y_hat = theta0 + theta1*X1 + theta2*X2
    errors = y_hat - y
    return np.dot(errors, errors) / (2*m)


#defining values
X1 = df['Engine Size(L)'].values
X2 = df['Cylinders'].values
y = df['CO2 Emissions(g/km)'].values
theta0 = 0.0
theta1 = 0.0
theta2 = 0.0
alpha = 0.0001
epochs = 100
m = len(y)
startingCost = compute_cost(theta0, theta1, theta2, X1, X2, y)

#printing initial values
print("Starting theta0:", theta0)
print("Starting theta1:", theta1)
print("Starting theta2:", theta2)
print("Learning rate (alpha):", alpha)
print("Epochs:", epochs)
print("Starting Cost:", startingCost)



#loop for gradient descent
costs = []
for i in range(epochs):
    y_hat = theta0 + theta1*X1 + theta2*X2
    errors = y_hat - y

    # Compute gradients
    grad_theta0 = (1/m) * np.sum(errors)
    grad_theta1 = (1/m) * np.sum(errors * X1)
    grad_theta2 = (1/m) * np.sum(errors * X2)

    # Update parameters
    theta0 -= alpha * grad_theta0
    theta1 -= alpha * grad_theta1
    theta2 -= alpha * grad_theta2

    J = compute_cost(theta0, theta1, theta2, X1, X2, y)
    costs.append(J)

    # Plot hypothesis line every 20 iterations
    if i % 20 == 0:
        plt.scatter(X1, y, color="blue")
        plt.plot(X1, theta0 + theta1*X1 + theta2*X2, color="red")
        plt.title(f"Epoch {i}")
        plt.xlabel("Engine Size")
        plt.ylabel("CO2 Emissions")
        plt.show()

        #CONTOUR GRAPH

        #######
        engine_size_grid, cylinders_grid = np.meshgrid(
            np.linspace(min(X1), max(X1), 100),
            np.linspace(min(X2), max(X2), 100)
        )
        
        # Predict CO2 on the grid using trained parameters
        CO2_pred = theta0 + theta1*engine_size_grid + theta2*cylinders_grid
        
        # Create contour plot
        plt.figure(figsize=(8,6))
        contour = plt.contourf(engine_size_grid, cylinders_grid, CO2_pred, 
                               levels=20, cmap='viridis', alpha=0.8)
        
        # Plot the actual data points
        plt.scatter(X1, X2, c=y, edgecolors='black', cmap='viridis', label="Actual Data")
        
        # Add color bar to show CO2 levels
        cbar = plt.colorbar(contour)
        cbar.set_label("Predicted CO2 Emissions")
        
        # Labels and title
        plt.xlabel("Engine Size")
        plt.ylabel("Cylinders")
        plt.title("Contour Plot: CO2 Emissions vs Engine Size & Cylinders")
        plt.legend()
        plt.show()


# Print final statistics ---
print("Final theta0:", theta0)
print("Final theta1:", theta1)
print("Final theta2:", theta2)
print("Final cost:", costs[-1])




#CONTOUR GRAPH

#######
engine_size_grid, cylinders_grid = np.meshgrid(
    np.linspace(min(X1), max(X1), 100),
    np.linspace(min(X2), max(X2), 100)
)

# Predict CO2 on the grid using trained parameters
CO2_pred = theta0 + theta1*engine_size_grid + theta2*cylinders_grid

# Create contour plot
plt.figure(figsize=(8,6))
contour = plt.contourf(engine_size_grid, cylinders_grid, CO2_pred, 
                       levels=20, cmap='viridis', alpha=0.8)

# Plot the actual data points
plt.scatter(X1, X2, c=y, edgecolors='black', cmap='viridis', label="Actual Data")

# Add color bar to show CO2 levels
cbar = plt.colorbar(contour)
cbar.set_label("Predicted CO2 Emissions")

# Labels and title
plt.xlabel("Engine Size")
plt.ylabel("Cylinders")
plt.title("Contour Plot: CO2 Emissions vs Engine Size & Cylinders")
plt.legend()
plt.show()







# Plot cost over time ---
plt.plot(range(epochs), costs, color="green")
plt.title("Cost Reduction Over Time")
plt.xlabel("Epoch")
plt.ylabel("Cost (MSE)")
plt.show()
